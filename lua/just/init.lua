-- Handle the output of the recipe and push to the quickfix list
--
-- TODO: there is no way to determine what type of output is generated
-- solely by running the recipe and therefore no way to add a meaningful
-- entry to the quickfix list.
--
-- The 'errorformat' option specifies a list of formats that are recognized.
-- The first match is being used.
-- One take on that is to just concatenate all the error formats and hope for the best
-- This approach would have the least control on how the errors are handled, except they
-- are parsed from the just recipes. This would allow to have fine control over
-- what error format is generated by what recipe. This is maybe the easiest approach to try.
-- Another approach would be to have just output a unified error format and set the error format in neovim to that...
local jobs = require("just.jobs")

local utils = require("just.utils")

local M = {}

local function completeRecipe(args)
    -- Match the command line arguments to all the available recipes and sugges
    -- those that contain the arguments
    local suggestionList = {}
    local justRecipes = jobs.justSummary()

    for _, recipe in pairs(justRecipes) do
        if string.find(recipe, args) then
            table.insert(suggestionList, recipe)
        end
    end

    return suggestionList
end

M.setup = function(_)
    vim.api.nvim_create_user_command("Just", function(args)
        -- No parameter passed
        if not args.fargs[1] then
            -- TODO: open prompt to select the recipe of none is passed instead
            -- utils.printTable(jobs.justList())
            return
        end

        -- TODO handle multiple arguments
        local recipeName = args.fargs[1]

        utils.clearQuickfix()
        utils.setQuickfixTitle("Just recipe: " .. args.fargs[1])
        jobs.justRunAsync(recipeName, true)
    end, {
        nargs = "*",
        complete = completeRecipe,
    })
end

return M
