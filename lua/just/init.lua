local Job = require("plenary.job")

local utils = require("just.utils")

local M = {}

local justSummary = Job:new({
	command = "just",
	args = { "--summary" },
})

local justList = Job:new({
	command = "just",
	args = { "--list" },
})

M.setup = function(opts)
	vim.api.nvim_create_user_command("Just", function(opts)
		local stdout_results = {}
		local stderr_results = {}

		local justJob = Job:new({
			command = "just",
			args = { opts.fargs[1] },
			-- is this callback broken, or how is it properly used to get stoud?
			on_stdout = function(what, line)
				if what then
					table.insert(what)
				end
				table.insert(stdout_results, line)
			end,
			on_stderr = function(what, line)
				if what then
					table.insert(what)
				end
				table.insert(stderr_results, line)
			end,
		})
		justJob:sync()

		-- Handle the output of the recipe and push to the quickfix list
		--
		-- TODO: there is no way to determine what type of output is generated
		-- solely by running the recipe and therefore no way to add a meaningful
		-- entry to the quickfix list.
		--
		-- The 'errorformat' option specifies a list of formats that are recognized.
		-- The first match is being used.
		-- One take on that is to just concatenate all the error formats and hope for the best
		-- This approach would have the least control on how the errors are handled, except they
		-- are parsed from the just recipes. This would allow to have fine control over
		-- what error format is generated by what recipe. This is maybe the easiest approach to try.

		vim.fn.setqflist({}, "r") -- reset the quickfix list

		-- utils.printTable(justSummary:result())
		-- print("result: " .. vim.inspect(justJob:result()))
		print("stdout: " .. vim.inspect(stdout_results))
		print("stderr: " .. vim.inspect(stderr_results))

		vim.fn.setqflist()
		vim.api.nvim_command("copen")
	end, {
		bang = true,
		nargs = 1,
		complete = function()
			justSummary:sync() -- or start()
			return utils.splitString(justSummary:result()[1], " ")
		end,
	})
end

return M
